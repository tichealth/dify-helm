# Dify Helm Chart Values for AKS
# Using dify-helm from https://borispolonsky.github.io/dify-helm
# Configured for Azure Kubernetes Service
#
# CPU: D4s_v5 × 0.5 for D2ads_v6 (2 vCPU). CPU limits removed – pods share node CPU.
# Memory limits kept. CPU requests used for SCHEDULING only (pods can burst beyond requests at runtime).
# Total CPU requests ~1000m (50% of 2 vCPU) ensures all pods can schedule; runtime usage can exceed this.

global:
  edition: "SELF_HOSTED"
  appSecretKey: "PleaseReplaceThisToYourSecretOrUse"
  internalApiKey: ""

# Image versions
image:
  api:
    repository: langgenius/dify-api
    tag: "1.11.2"
    pullPolicy: IfNotPresent
  web:
    repository: langgenius/dify-web
    tag: "1.11.2"
    pullPolicy: IfNotPresent
  sandbox:
    repository: langgenius/dify-sandbox
    tag: "0.2.12"  # Updated to match docker-compose.yaml for Dify 1.11.2
    pullPolicy: IfNotPresent
  proxy:
    repository: nginx
    tag: latest
    pullPolicy: IfNotPresent
  ssrfProxy:
    repository: ubuntu/squid
    tag: latest
    pullPolicy: IfNotPresent
  pluginDaemon:
    repository: langgenius/dify-plugin-daemon
    tag: "0.5.2-local"  # Updated from 0.1.1-local to match docker-compose.yaml for Dify 1.11.2
    pullPolicy: IfNotPresent

# API Configuration
# CPU share: requests only, no CPU limit. 100m request for scheduling.
api:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "512Mi"
      cpu: "100m"
    limits:
      memory: "2Gi"
  persistence:
    enabled: true
    persistentVolumeClaim:
      storageClass: "azurefile"
      accessModes: ReadWriteMany
      size: 5Gi

# Worker Configuration
# CPU share: requests only. 100m request for scheduling.
worker:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "1Gi"

# Worker Beat Configuration
# CPU share: no CPU limit. 100m request.
beat:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"

# Web (Frontend) Configuration
# CPU share: no CPU limit.
web:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "512Mi"
      cpu: "125m"
    limits:
      memory: "2Gi"

# Sandbox Configuration
# CPU share: no CPU limit.
sandbox:
  enabled: true
  replicas: 1
  auth:
    apiKey: "dify-sandbox"
  resources:
    requests:
      memory: "512Mi"
      cpu: "125m"
    limits:
      memory: "1Gi"

# SSRF Proxy Configuration
# CPU share: no CPU limit.
ssrfProxy:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "50m"
    limits:
      memory: "512Mi"

# Plugin Daemon Configuration
# CPU share: no CPU limit. 100m request so it fits on 2 vCPU node with other Dify pods.
pluginDaemon:
  enabled: true
  replicas: 1
  auth:
    serverKey: "lYkiYYT6owG+71oLerGzA7GXCgOT++6ovaezWAjpCjf+Sjc3ZtU+qUEi"
    difyApiKey: "QaHbTe77CtuXmsfyhR7+vRjI/+XbV1AaFy691iy+kGDv2Jvy0/eAh8Y1"
  extraEnv:
    - name: PGSSLMODE
      value: "require"  # Azure PostgreSQL requires SSL (when postgres_require_secure_transport = true)
    - name: DB_SSLMODE
      value: "require"
  resources:
    requests:
      memory: "512Mi"
      cpu: "100m"
    limits:
      memory: "2048Mi"
  persistence:
    enabled: true
    persistentVolumeClaim:
      storageClass: "azurefile"
      accessModes: ReadWriteMany
      size: 20Gi

# Proxy (Nginx) Configuration
# CPU share: no CPU limit.
proxy:
  enabled: true
  replicas: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "25m"
    limits:
      memory: "256Mi"

# Service Configuration - Use ClusterIP (Ingress handles external access)
service:
  type: ClusterIP  # Changed from LoadBalancer
  port: 80

# Ingress Configuration - Enable and configure
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"  # Use "letsencrypt-staging" for testing
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/proxy-body-size: "100m"
  hosts:
    - host: dify-dev.tichealth.com.au
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: dify-tls
      hosts:
        - dify-dev.tichealth.com.au

# PostgreSQL Configuration - Using Azure PostgreSQL Flexible Server (external)
postgresql:
  enabled: false  # Disable in-cluster PostgreSQL

externalPostgres:
  enabled: true
  username: "difyadmin"
  password: "difyai123456"
  # address: set by deploy.sh from `terraform output postgresql_fqdn` when using Azure Postgres
  address: "override-by-deploy-script"
  port: 5432
  database:
    api: "dify"  # Main Dify database
    pluginDaemon: "dify_plugin"  # Plugin daemon database (created by Terraform)

# Redis Configuration (using Bitnami subchart)
redis:
  enabled: true
  auth:
    password: "difyai123456"
  master:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      requests:
        memory: "256Mi"
        cpu: "50m"
      limits:
        memory: "512Mi"
  replica:
    replicaCount: 0  # Disable replicas for now

# Weaviate disabled (we'll use Qdrant)
weaviate:
  enabled: false

# External Qdrant Configuration
# Note: We need to deploy Qdrant separately or add it as a subchart
# For now, configure as external - we'll deploy Qdrant separately
externalQdrant:
  enabled: true
  endpoint: "http://dify-qdrant:6333"  # Update after Qdrant is deployed
  apiKey: "difyai123456"

# Storage Configuration (using local persistence for now)
externalS3:
  enabled: false

# External Secrets (disabled for now)
externalSecret:
  enabled: false
